<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SASS基础语法(一)]]></title>
    <url>%2FSASS%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E4%B8%80.html</url>
    <content type="text"><![CDATA[SASS基础语法学习一. 引言 本文仅仅记录自己的学习历程，作为自己日后翻阅复习之用，并无什么高深的见解，只为温故而知新… 二. 官方网站网： SASS中文网1. 安装 Sass有以下几种安装方式： 使用独立的安装包（各平台，需要手动添加环境变量） 链接… 使用NPM安装（各平台） 使用Chocolatey包管理工具安装（Windows） 使用Brew安装（macOS） Windows下需先安装Ruby注意：安装过程中请注意勾选Add Ruby executables to your PATH添加到系统环境变量 测试安装有没有成功 123ruby -v//如安装成功会打印ruby 2.2.2p95 (2015-04-13 revision 50295) [i386-mingw32] 更换gem源 123456789101112//1.删除原gem源gem sources --remove https://rubygems.org///2.添加国内淘宝源gem sources -a https://ruby.taobao.org///3.打印是否替换成功gem sources -l//4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 安装Sass和Compass使用Ruby自带的RubyGems系统 123//安装如下(如mac安装遇到权限问题需加 sudo gem install sass)gem install sassgem install compass sass常用更新、查看版本、sass命令帮助等命令： 12345678//更新sassgem update sass//查看sass版本sass -v//查看sass帮助sass -h 编译sass 命令行编译 12345678//单文件转换命令sass input.scss output.css//单文件监听命令sass --watch input.scss:output.css//如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：sass --watch app/sass:public/stylesheets 软件方式编译推荐koala&amp; codekit 2. SASS与SCSS .SASS它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式。这种格式以 .scss 作为拓展名。 123h1 color: #f00 background:#fff; .SCSS仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。 123h1&#123; color:#f00; background:#fff; 三. 变量的使用1. 变量申明 $ 写法：$highlight-color：#fff； 全局变量变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量）；不在嵌套规则内定义的变量则可在任何地方使用（全局变量） 将局部变量转换为全局变量可以添加 !global 2. 变量的引用 凡是css属性的标准值可存在的地方，变量就可以使用 3. 变量名 sass的变量名可以与css中的属性名和选择器名称相同，包括中划线、下划线 中划线和下划线两种方式是相互兼容的；用中划线声明的变量可以使用下划线的方式引用，反之亦然 四. 嵌套规则1. 父选择器标识符 —- &amp; 为父级元素添加 :hover等伪类时使用 &amp;还有另一种用法，可以在父选择器之前添加选择器 例如：在ie浏览器下才显示的样式 1234567#content aside &#123; color: red; body.ie &amp; &#123; color: green &#125;&#125;//编译后#content aside &#123;color: red&#125;;body.ie #content aside &#123; color: green &#125; 2. 群组选择器的嵌套 群组选择器规则内嵌的规则 12345.container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125;//编译为.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125; 内嵌在群组选择器的嵌套规则 12345nav, aside &#123; a &#123;color: blue&#125;&#125;//编译为nav a, aside a &#123;color: blue&#125; 3. &gt;、+和~ 可以把他们放在外层选择器后边或者里层选择器的前边： 123456789101112131415article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125;//编译为article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 4. 属性嵌套 在sass中属性也是可以嵌套的 嵌套属性的规则： 把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。就像css选择器嵌套一样，sass会把你的子属性一一解开，把根属性和子属性部分通过中划线-连接起来，最后生成的效果与你手动一遍遍写的css样式一样： 五. 导入SASS文件 随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。sass通过对css原有@import规则的改进直接支持了这一特性。 1. 利用@import规则 所有在被导入文件中定义的变量和混合器均可以在导入文件中使用导入文件时，可不用指明文件的全名，可省略文件后缀 2. 使用SASS部分文件 局部文件 那些专门为import命令而写的sass文件，并不需要生成对应的独立css文件，这样的sass文件成为局部文件 对于局部文件，有一些约定： 文件名以下划线开头：这样sass就不会在编译时单独编译这个文件输出css，而只是把这个文件用作导入 导入局部文件时，还可以不写文件按的全名，即省略文件名开头的下划线 可以被多个不同的文件引用 3. 默认变量值 反复申明同一个变量，最后一处申明会覆盖之前的值 利用 !default 标签，其含义是：如果这个变量被申明赋值了，那就用它申明的值，否则就用这个默认值 4. 嵌套导入 sass允许@import命令写在css规则内 被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效；这些变量和混合器不会全局有效。 5. 原生的CSS导入 不能用sass的@import直接导入以个原始的css文件，sass会误认为你是想用css原生的@import 因为sass语法完全兼容css，所以可以把原始的css’文件改名为.scss后缀 6. 静默注释 以//开头，注释内容直到行末 这种注释不会出现在生成的长css文件中 7. 混合器 当你的样式变得越来越复杂时，需要大段重用样式的代码的时候，独立变量就没法应付了；而通过混合器可以简单解决这一问题 避免滥用混合器 混合器中的CSS规则可以在混合器中使用嵌套规则；也可以使用&amp;符 给混合器传参 默认参数值通过$name:default-value的生命形式；默认值可以是写法与JS的function很像： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 可通过语法$name：value的形式来指定每个参数的值，这样就不用考虑参数的顺序了 8. 使用选择器继承(@extend)来精简CSS 减少重复的特性 基于面向对象的css的理念，利用继承器可以继承为另一个选择器定义的所有样式 通过@extend语法实现** 何时使用继承 混合器主要是用于展示性样式的重用，而类名是用于语义化样式的重用，所以继承应该是建立在语义化的关系上。一般在一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式时，可选用@extend的方式来继承样式 继承的高级用法 任何css规则都可以继承其他规则，几乎任何css规则也都可以被继承 六. 待续…]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>Sass</tag>
        <tag>CSS</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也不知道在写什么]]></title>
    <url>%2F%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E5%9C%A8%E5%86%99%E4%BB%80%E4%B9%88.html</url>
    <content type="text"><![CDATA[Singleton与Static的区别1. singleton 单例模式 单例模式，单例模式是一种被广泛使用的设计模式。指的是在应用整个生命周期内只能存在一个实例。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。 单例模式的特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其它对象提供这一实例。 单例模式的好处 使用单例模式可以限制对象实例的个数，除了返回实例的操作之外不能被new出来。这在某些需要限制对象访问的场合下是有用的。使用static的话并不能限制对象实例的个数。 在很多的操作中，比如说是建立目录、数据库操作等都需要这样的单线程操作。 最显而易见的好处是节约开销，比如数据库单例的好处是，每次你只需要去获取那个数据库的示例就好，不用每次都去创建一个实例。 2. static 静态类 静态类就是一个类里面都是静态方法和静态field，构造器被private修饰，因此不能被实例化。Math类就是一个静态类。 静态类的特点 只包含静态成员。 无法进行实例化。也就是无法使用new运算符创建类类型的变量，因此可以通过类名.变量名直接引用，而不需要new出一个类来 静态方法通常用于创建实用程序函数。不能包含实例构造函数。静态方法的调用直接在类上进行，不能在类的实例上调用。 会进行密封，因此不能继承。 它们不能继承自任何类（除了Object） 静态类的好处 static类有更好的效率。 编译器可以进行检查。 3. 区别 静态方法只能直接访问本类中的静态成员（通过实例化对象）可以访问到的其它类中的所有成员（包括静态和非静态） static有更好的访问效率，如果你的singleton不维持任何状态，仅仅是提供全局的访问，这个时候就适合用static，这样速度的也快； 静态类中只能有静态成员，不可以有非静态字段； 单例模式的灵活性更高，方法可以被override，因为静态类都是静态方法，所以不能被override； 单例模式会提供给你一个全局唯一的对象，静态类只是提供给你很多静态方法，这些方法不用创建对象，通过类就可以直接调用； 单例模式最大的好处就是节省内存空间，提高效率，因为他永远都只有一个实例！而static还是有可能被new出多个实例的，而这多个实例在用完之后也许就没用了，还要等待垃圾回收机制来回收，所以效率自然不如单例； 如果是一个非常重的对象，单例模式可以懒加载，静态类就无法做到； 什么是进程？** 当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源。而一个进程又是由多个线程所组成的。 什么是线程 线程是程序中的一个执行流，每个线程都有自己的专有寄存器(栈指针、程序计数器等)，但代码区是共享的，即不同的线程可以执行同样的函数。 什么是多线程？ 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。 多线程的好处： 可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率。 多线程的不利方面： 线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； 多线程需要协调和管理，所以需要CPU时间跟踪线程； 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题； 线程太多会导致控制太复杂，最终可能造成很多Bug。 参考链接：https://www.cnblogs.com/scotth/p/10450891.html]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>singleton</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面试题收藏（持续更新中...）]]></title>
    <url>%2FJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E8%97%8F.html</url>
    <content type="text"><![CDATA[前言 本文仅记录平时学习过程中遇到的知识点，只实现了相应方法的核心原理，部分边界细节并未处理。为了防止日后遗忘，特此记录，方便日后记忆，学习之用！ 1. 实现一个call函数123456789101112// 将要改变this指向的方法挂到目标this上执行并返回Function.prototype.mycall = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let arg = [...arguments].slice(1) let result = context.fn(...arg) delete context.fn return result&#125; 2. 实现一个apply函数123456789101112131415Function.prototype.myapply = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 3. 实现一个bind函数123456789101112131415Function.prototype.mybind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; let _this = this let arg = [...arguments].slice(1) return function F() &#123; // 处理函数使用new的情况 if (this instanceof F) &#123; return new _this(...arg, ...arguments) &#125; else &#123; return _this.apply(context, arg.concat(...arguments)) &#125; &#125;&#125; 4. instanceof的原理1234567891011121314// 右边变量的原型存在于左边变量的原型链上function instanceOf(left, right) &#123; let leftValue = left.__proto__ let rightValue = right.prototype while (true) &#123; if (leftValue === null) &#123; return false &#125; if (leftValue === right) &#123; return true &#125; leftValue = rightValue.__proto__ &#125;&#125; 5. Object.create的基本实现原理1234function create(obj) &#123; function F() &#123;&#125; F.prototype = obj return new F() 6. new本质123456789101112131415161718function myNew (fun) &#123; return function () &#123; // 创建一个新对象且将其隐式原型指向构造函数原型 let obj = &#123; __proto__ : fun.prototype &#125; // 执行构造函数 fun.call(obj, ...arguments) // 返回该对象 return obj &#125;&#125;function person(name, age) &#123; this.name = name this.age = age&#125;let obj = myNew(person)('chen', 18) // &#123;name: "chen", age: 18&#125; 7. 实现一个基本的Promise123456789101112131415161718192021222324252627282930313233343536373839// ①自动执行函数，②三个状态，③thenclass Promise &#123; constructor (fn) &#123; // 三个状态 this.state = 'pending' this.value = undefined this.reason = undefined let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled' this.value = value &#125; &#125; let reject = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected' this.reason = value &#125; &#125; // 自动执行函数 try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125; // then then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case 'fulfilled': onFulfilled() break case 'rejected': onRejected() break default: &#125; &#125;&#125; 8. 实现浅拷贝123456// 1. ...实现let copy1 = &#123;...&#123;x:1&#125;&#125;// 2. Object.assign实现let copy2 = Object.assign(&#123;&#125;, &#123;x:1&#125;) 9. 实现一个基本的深拷贝1234567891011121314// 1. JOSN.stringify()/JSON.parse()let obj = &#123;a: 1, b: &#123;x: 3&#125;&#125;JSON.parse(JSON.stringify(obj))// 2. 递归拷贝function deepClone(obj) &#123; let copy = obj instanceof Array ? [] : &#123;&#125; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i] &#125; &#125; return copy&#125; 10. 使用setTimeout模拟setInterval12345// 可避免setInterval因执行时间导致的间隔执行时间不一致setTimeout (function () &#123; // do something setTimeout (arguments.callee, 500)&#125;, 500) 11. js实现一个继承方法// 借用构造函数继承实例属性123456789function Child () &#123; Parent.call(this)&#125;// 寄生继承原型属性(function () &#123; let Super = function () &#123;&#125; Super.prototype = Parent.prototype Child.prototype = new Super()&#125;)() 12. 实现一个基本的Event Bus123456789101112131415161718192021222324252627// 组件通信，一个触发与监听的过程class EventEmitter &#123; constructor () &#123; // 存储事件 this.events = this.events || new Map() &#125; // 监听事件 addListener (type, fn) &#123; if (!this.events.get(type)) &#123; this.events.set(type, fn) &#125; &#125; // 触发事件 emit (type) &#123; let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) &#125;&#125;// 测试let emitter = new EventEmitter()// 监听事件emitter.addListener('ages', age =&gt; &#123; console.log(age)&#125;)// 触发事件emitter.emit('ages', 18) // 18 13. 实现一个双向数据绑定12345678910111213141516171819let obj = &#123;&#125;let input = document.getElementById('input')let span = document.getElementById('span')Object.defineProperty(obj, 'text', &#123; configurable: true, enumerable: true, get() &#123; console.log('获取数据了') return obj.text &#125;, set(newVal) &#123; console.log('数据更新了') input.value = newVal span.innerHTML = newVal &#125;&#125;)input.addEventListener('keyup', function(e) &#123; obj.text = e.target.value&#125;) 14. 实现一个简单路由12345678910111213141516171819202122class Route&#123; constructor()&#123; // 路由存储对象 this.routes = &#123;&#125; // 当前hash this.currentHash = '' // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener('load', this.freshRoute, false) window.addEventListener('hashchange', this.freshRoute, false) &#125; // 存储 storeRoute (path, cb) &#123; this.routes[path] = cb || function () &#123;&#125; &#125; // 更新 freshRoute () &#123; this.currentHash = location.hash.slice(1) || '/' this.routes[this.currentHash]() &#125;&#125; 15. 实现懒加载123456789101112&lt;ul&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/1.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/2.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/3.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/4.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/5.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/6.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/7.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/8.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/9.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/10.png" alt=""&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516let imgs = document.querySelectorAll('img')// 可视区高度let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeightfunction lazyLoad () &#123; // 滚动卷去的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop for (let i = 0; i &lt; imgs.length; i ++) &#123; // 得到图片顶部距离可视区顶部的距离 let x = clientHeight + scrollTop - imgs[i].offsetTop // 图片在可视区内 if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123; imgs[i].src = imgs[i].getAttribute('data') &#125; &#125;&#125;setInterval(lazyLoad, 1000) 16. rem实现原理1234567function setRem () &#123; let doc = document.documentElement let width = doc.getBoundingClientRect().width // 假设设计稿为宽750，则rem为10px let rem = width / 75 doc.style.fontSize = rem + 'px'&#125; 17. 手写实现AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 1. 简单实现// 实例化let xhr = new XMLHttpRequest()// 初始化xhr.open(method, url, async)// 发送请求xhr.send(data)// 设置状态变化回调处理请求结果xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 2. 基于promise实现function ajax (options) &#123; // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || 'get' // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; // 返回一个Promise实例 return new Promise ((resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject('请求超时') // 监听状态变化回调 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; // 错误回调 xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key])) &#125; encodeData = paramArr.join('&amp;') &#125; // get请求拼接参数 if (method === 'get') &#123; // 检测url中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&amp;' // 拼接url url += encodeData &#125; // 初始化 xhr.open(method, url, async) // 发送请求 if (method === 'get') xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) &#125; &#125;)&#125; 18. 实现拖拽1234567891011121314151617181920212223242526272829303132window.onload = function () &#123; // drag处于绝对定位状态 let drag = document.getElementById('box') drag.onmousedown = function(e) &#123; var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) &#123; // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left &lt; 0) &#123; left = 0 &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123; left = window.innerWidth - drag.offsetWidth &#125; if (top &lt; 0) &#123; top = 0 &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123; top = window.innerHeight - drag.offsetHeight &#125; drag.style.left = left + 'px' drag.style.top = top + 'px' &#125; drag.onmouseup = function (e) &#123; this.onmousemove = null this.onmouseup = null &#125; &#125;&#125; 19. 实现一个节流函数123456789101112131415161718function throttle (fn, delay) &#123; // 利用闭包保存时间 let prev = Date.now() return function () &#123; let context = this let arg = arguments let now = Date.now() if (now - prev &gt;= delay) &#123; fn.apply(context, arg) prev = Date.now() &#125; &#125;&#125;function fn () &#123; console.log('节流')&#125;addEventListener('scroll', throttle(fn, 1000)) 20. 实现一个防抖函数12345678910111213141516function debounce (fn, delay) &#123; // 利用闭包保存定时器 let timer = null return function () &#123; let context = this let arg = arguments // 在规定时间内再次触发会先清除定时器后再重设定时器 clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(context, arg) &#125;, delay) &#125;&#125;function fn () &#123; console.log('防抖')&#125;addEventListener('scroll', debounce(fn, 1000)) 最后 后续也会持续更新，希望能对所有像我一样的前端新手都有所帮助。共同进步~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>-JavaScript -面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coding Pages申请SSL/TLS证书错误]]></title>
    <url>%2FCoding-Pages%E7%94%B3%E8%AF%B7SSL-TLS%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF.html</url>
    <content type="text"><![CDATA[问题今天由于某种原因，我将我的个人站点部署到了Coding Pages上面，需要申请SSL/TLS证书，但是当我登陆进入Coding Pages服务的后台并点击申请证书时，竟然报错了！！！ 我重新点了申请，几秒后依然报错，并提示我半小时只能申请一次。我查看了下报错的提示信息，如下： urn:acme:error:unauthorized:Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx 好吧，本着有事就问度娘的一贯风格，百度了一下，发现了Coding Pages的官方文件：Coding Pages 常见问题 这时候按照官方文件的指引，找到了和我差不多一样的错误信息的解决方案： 错误原因：无法获取正确的域名验证信息解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 因为Coding Pages的静态Pages是免费的，而动态Pages是收费的，对于用Hexo搭建的静态站点，自然是选择免费的静态Pages服务就足够了。 于是解决方式1对我来说就不存在了，接着联想到之前我对部署在GitHub Pages上的个人站点进行了自定义域名绑定+域名解析设置，有些豁然开朗的感觉。 分析由于考虑到站点访问速度，以及后期SEO的各种问题，因此我的个人站点是同时部署到GitHub Pages和Coding Pages上的，接着在腾讯云域名解析里进行了配置：默认的解析线路将我的域名指向pages.coding.me，国外的解析路线则是指向了xxx.github.io。 之所以这样配置，是因为国内部分地区无法直接访问GitHub，自然就无法访问我部署在GitHub上的个人站点，于是我又选择了Coding.net的Pages服务，这样国内用户就可以快速访问到我部署在Coding Pages的个人站点，而国外用户则是快速访问到GitHub Pages上的个人站点。 问题就出现在这里，因为我第一次申请SSL/TLS证书的时候，还没有解析境外的线路，所以很快就申请成功了。后来添加了国外线路的解析，这导致在Coding Pages的后台申请证书时无法通过验证，自然就申请失败了。 分析到这里，我也基本知道怎么解决这个错误了。 解决方法由于我是在腾讯云购买的域名，于是登陆到腾讯云域名解析的后台系统，打开个人域名的解析设置，暂停对于境外线路的解析。这里暂停就行了，一般来说大概需要5分钟左右的生效时间，毕竟DNS解析是存在缓存的。 五分钟后，我又进入Coding Pages服务的后台，再一次申请SSL/TLS证书，果不其然，几秒钟后我申请证书成功了。 最后，再次返回腾讯云域名解析的后台，将境外解析的线路再次启用，嗯，完美！！！ 其他的申请错误个人暂时就遇到这一个问题，有其他问题的伙伴可自行查阅官方文件Coding Pages 常见问题。 明日灵笼上线，喜欢的小伙伴一起啊~~ 参考链接 Coding Pages的官方文件：Coding Pages 常见问题 https://www.cnblogs.com/yulinlewis/p/9595362.html]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法]]></title>
    <url>%2FMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[Markdown基础语法 一、概述 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的特点就是，让写作变得更简单，我们不用再考虑如何排版，我们只要专心于写作就好了，其目标就是实现「易读易写」。 二、基础语法2.1 标题 Markdown支持6种级别的标题，一个#是一级标题，二个#是二级标题，以此类推，对应html标签 h1 ~ h6。 除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制。使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。 示例： 1234567891011# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是三级标题 ###### 这是四级标题 以上标记显示效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是三级标题这是四级标题 2.2 文本1. 加粗​ 要加粗的文字左右分别用两个*号（或_号）包起来 2. 斜体​ 要倾斜的文字左右分别用一个*号或（或_号）包起来 3. 斜体加粗​ 文字左右分别用三个*号或（或_号）包起来 4. 下划线​ 使用&lt;u&gt;&lt;/u&gt;，中间写入内容 5. 删除线​ 要加删除线的文字左右分别用两个~~号包起来 ​ 以上標記示例： 123456789**这是加粗的文字***这是倾斜的而文字****这是斜体加粗的文字*** &lt;u&gt;这是有下划线的文字&lt;/u&gt;~~这是加出现的文字~~ ​ 以上标记显示效果如下： ​ 这是加粗的文字 ​ 这是倾斜的而文字 ​ 这是斜体加粗的文字 ​ 这是有下划线的文字 ​ 这是加出现的文字 PS：空行输入&amp;nbsp；换行的话要隔一行 2.3 列表1. 有序列表​ 语法：数字+点 Markdown将只关注你的第一个项目的数字编号，之后按enter会自动排序 ​ 示例： 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 ​ 效果如下： 列表內容 列表內容 列表內容 2. 无序列表​ 语法：用 _ + * 任意一种都可以 ​ 示例： 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 ​ 效果如下： 列表内容 列表内容 列表内容 ​ 列表是可以嵌套的！ 3. 任务列表​ 示例： 123- [ ] 围天安门跑三百圈- [x] 教学计划- [ ] 读一本书 ​ 效果展示： 围天安门跑三百圈 教学计划 读一本书 2.4 引用​ 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个… ​ 示例： 123&gt; Typora热爱文字更佳，码农或者文字工作者必备神器&gt;&gt; 所見所得的Markdown編輯器&gt;&gt;&gt; 書寫即為美學！ ​ 效果如下： Typora热爱文字更佳，码农或者文字工作者必备神器 所見所得的Markdown編輯器 書寫即為美學！ 2.5 图片​ 语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ​ 示例： 1![图片](https://picgo-img-1259503129.cos.ap-beijing.myqcloud.com/c31f7fdc1bb4d377e6e11073240bdcfc.jpg) ​ 效果如下： 2.6 超链接​ 语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 ​ 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) ​ 效果： ​ 简书​ 百度 注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。 2.7 分割线​ 三个或者三个以上的 - 或者 * 都可以。 示例： 1234*******------- 效果如下： 2.8 表格表格是Markdown语法中比较复杂的一个，其语法如下： 1234表头|条目一|条目二|:---:|:---:|:---:||项目|项目一|项目二| 示例： 123456姓名|技能|排行|:--:|:--:|:--:|:|刘备|哭|大哥||关羽|打|二哥||张飞|骂|三弟| 其效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 罵 三弟 ​ 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中，文字默认居中。 2.9 代码块 单行代码 语法：代码之间分别用一个反引号包起来 1`代码内容` 示例： 1`console.log(123456);` 效果： console.log(123456); 代码块 语法：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...​(```) 示例： 12345678(```)javascriptvar txt = &quot;&quot;;var numbers = [45, 4, 9, 16, 25]; numbers.forEach(myFunction);function myFunction(value) &#123; txt = txt + value + &quot;&lt;br&gt;; &#125;(```) 注意：这里的（）是为了防止转义，实际操作中没有括号 效果： 1234567 var txt = "";var numbers = [45, 4, 9, 16, 25]; numbers.forEach(myFunction);function myFunction(value) &#123; txt = txt + value + "&lt;br&gt;"; &#125; 注意：代码高亮需要在开头的三个反引号后面写上选用哪种语言 2.10 反斜杠 反斜杠相当于转义的作用，是一些符号以普通的符号显示出来 Markdown使用反斜杠\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理： 12345678910111213\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。 三、总结 Markdown的一些高级用法，像数学公式、制图等，小伙伴儿们可以参考官网的案例，我这里呢..就没必要去记了😂😂😂Markdown对喜欢写作的小伙伴儿们来说是一门必备的技能。如果你希望快速掌握Markdown，很简单，动起来吧！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博文]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87.html</url>
    <content type="text"><![CDATA[新手写博客应该写些什么~最近刚搭建了这么个博客，奈何自己也是前端小白一枚，苦于不知道该写什么比较好。于是乎，各种问度娘，借鉴各种大神的作品，最终总结出如下适合自己目前状况的一种套路： 内容为王，拒绝copy 一路坚持，总有收获 博客内容入门系列 备忘录 主要记录平时自己常用到的，容易忽视的一些知识，作为自己知识的巩固，也可以写自己收藏的比较好的网站，文章的分享等等，当然也可以写自己最近的计划之类的。 学习笔记 这一块可以写的东西好多，只要是自己平时get到的技能点，都可以写上去。 读书笔记 基础理解 学习心得 踩坑记录 自己工作中，学习中遇到的各种坑，你可以记录下来，总不能下次遇见在此掉进里面吧…，如果恰巧能帮助到别人一下下，那可是功德一件啊~ 生活随笔 个人日记什么的，自己个人呢有点想写，但怎么感觉有点怪怪的… 还是觉得，自己的小本本写着比较安心… 想写在自己博客的话，文章也是可以加密的！ 实战类 环境搭建 操作记录 主要写一些实战中，某些环境的搭建过程，操作步骤等 不要担心写的不好什么的，一定要自己动手写！坚持这么一年半载之后呢，就可以写一些比较深的东西了，比如： 模式的提炼 造轮子，各种可复用的组件等 各种工具的使用，源码分析 开源项目 和大家一样，我也是刚刚开始，记录以上内容，希望能一起进步。 路漫漫其修远兮，吾将上下而求索！ 坚持就是胜利，一起加油呀！ 共勉~ 参考链接 B站优质up主：CodeSheep]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
