<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WPF学习笔记(二)资源与触发器]]></title>
    <url>%2FWPF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E8%B5%84%E6%BA%90%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8.html</url>
    <content type="text"><![CDATA[WPF学习笔记(二)资源与触发器一、WPF资源 WPF资源系统可以用来保存一些公有对象和样式，从而实现重用这些对象和样式的作用。而WPF样式是重用元素的格式的重要手段，可以理解样式就如CSS一样，尽管我们可以在每个控件中定义格式，但是如果多个控件都应用了多个格式的时候，我们就可以把这些格式封装成格式，然后在资源中定义这个格式，之前如果用到这个格式就可以直接使用这个样式，从而达到重用格式的手段。从中可以发现，WPF资源和WPF样式是相关的，我们经常把样式定义在资源中。 1.1 资源基础介绍 我们可以在代码中创建和操作资源，但通常都是以XAML标签的形式定义资源的。 具体的XAML代码如下所示： 123456789101112131415161718&lt;Window x:Class=&quot;WpfApp1.Execise&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:WpfApp1&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Execise&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt; &lt;!--定义资源--&gt; &lt;Window.Resources&gt; &lt;SolidColorBrush x:Key=&quot;Button1&quot; Color=&quot;Red&quot; /&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;!--通过资源key来对资源进行使用--&gt; &lt;Button Foreground=&quot;&#123;StaticResource Button1&#125;&quot; Width=&quot;100&quot; Height=&quot;100&quot; Content=&quot;Hello&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 效果图如下： 1.2 静态资源和动态资源的区别 为了使用XAML标记中的资源，需要一种引用资源的方法，可以通过两个标记来进行引用资源：一个用于静态资源，另一个用于动态资源。在上面的XAML中，我们引用的方式就是静态资源的引用方式，因为我们指定了StaticResource。 对于静态资源在第一次创建窗口时，一次性地设置完毕；而对于动态资源，如果发生了改变，则会重新应用资源。 例子： 12345678910111213141516&lt;Window.Resources&gt; &lt;SolidColorBrush x:Key=&quot;RedBrush&quot; Color=&quot;Red&quot;&gt;&lt;/SolidColorBrush&gt;&lt;/Window.Resources&gt;&lt;StackPanel Margin=&quot;5&quot;&gt; &lt;Button Background=&quot;&#123;StaticResource RedBrush&#125;&quot; Margin=&quot;5&quot; FontSize=&quot;14&quot; Content=&quot;Use a Static Resource&quot;/&gt; &lt;Button Background=&quot;&#123;DynamicResource RedBrush&#125;&quot; Margin=&quot;5&quot; FontSize=&quot;14&quot; Content=&quot;Use a Dynamic Resource&quot;/&gt; &lt;Button Margin=&quot;5&quot; FontSize=&quot;14&quot; Content=&quot;Change the RedBrush to Yellow&quot; Click=&quot;ChangeBrushToYellow_Click&quot;/&gt;&lt;/StackPanel&gt;&lt;!--后台代码--&gt;private void ChangeBrushToYellow_Click(object sender, RoutedEventArgs e)&#123; // 改变资源 this.Resources[&quot;RedBrush&quot;] = new SolidColorBrush(Colors.Yellow);&#125; 点击按钮，只会改变动态引用资源的背景色，静态资源并没有改变。效果图如下： 1.3 资源字典 每个Resources属性存储着一个资源字典集合。如果希望在多个项目之间共享资源的话，就可以创建一个资源字典。 资源字段是一个简单的XAML文档，该文档就是用于存储资源的，可以通过右键项目-&gt;添加资源字典的方式来添加一个资源字典文件: 123456&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:WpfApp1&quot;&gt; &lt;SolidColorBrush x:Key=&quot;blueBrush&quot; Color=&quot;Blue&quot;/&gt; &lt;FontWeight x:Key=&quot;fontWeight&quot;&gt;Bold&lt;/FontWeight&gt;&lt;/ResourceDictionary&gt; 为了使用资源字典，需要将其合并到应用程序中资源集合位置，当然你也可以合并到窗口资源集合中，但是通常是合并到应用程序资源集合中，因为资源字典的目的就是在于多个窗体中共享，具体的XAML代码如下所示： 1234567891011121314&lt;Application x:Class=&quot;WpfApp1.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:WpfApp1&quot; StartupUri=&quot;Execise.xaml&quot;&gt; &lt;Application.Resources&gt; &lt;!--合并资源字典到Application.Resources中--&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Dictionary1.xaml&quot;/&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/Application.Resources&gt;&lt;/Application&gt; 使用方式与引用资源的方式是一样的： 123456789101112131415161718&lt;Window x:Class=&quot;WpfApp1.Execise&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:WpfApp1&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Execise&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt; &lt;Window.Resources&gt; &lt;SolidColorBrush x:Key=&quot;RedBrush&quot; Color=&quot;Red&quot;&gt;&lt;/SolidColorBrush&gt; &lt;/Window.Resources&gt; &lt;StackPanel Margin=&quot;5&quot;&gt; &lt;!--使用资源字典中定义的资源--&gt; &lt;Button Margin=&quot;10&quot; Background=&quot;&#123;StaticResource blueBrush&#125;&quot; Content=&quot;Blue Button&quot; FontWeight=&quot;&#123;StaticResource fontWeight&#125;&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; 最终运行效果如下： 二、触发器Trigger 触发器，应用属性值或有条件地执行操作； 1）触发源：控件； 2）触发条件：某属性为某个值，或执行某个事件时； 3）执行操作：更改某个属性值或执行某个事件； 触发器是通过Style.Triggers集合链接到样式。每个样式都可以有任意多个触发器，而且每个触发器都是System.Windows.TriggerBase的派生类的集合。 三、触发器的分类 1）根据触发器的触发条件，在 WPF 中，触发器的形态可以是：Trigger、DataTrigger、EventTrigger； 2）以及由 Trigger 延伸的 MultiTrigger 和由 DataTrigger 延伸的 MultiDataTrigger； 3.1 Trigger Trigger 是最简单的触发器，主要用于监测依赖项属性的变化，然后使用设置器改变样式 实例：当鼠标移动到按钮时，按钮内容变为红色 12345678910111213141516&lt;Window.Resources&gt; &lt;Style x:Key=&quot;Buttonstyle&quot; TargetType=&quot;Button&quot;&gt; &lt;Style.Triggers&gt; &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;30&quot; /&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Red&quot;/&gt; &lt;/Trigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt;&lt;/Window.Resources&gt;&lt;StackPanel Margin=&quot;5&quot;&gt; &lt;Button Width=&quot;200&quot; Height=&quot;100&quot; Margin=&quot;10&quot; Content=&quot;Hello WPF&quot; Style=&quot;&#123;StaticResource Buttonstyle&#125;&quot;/&gt;&lt;/StackPanel&gt; 效果如下： 3.2 DataTrigger 该触发器使用数据绑定。与Trigger类似，只不过监视的是任意绑定数据的变化 3.3 EventTrigger 这是最复杂的触发器，当事件发生时，这种触发器应用动画 示例：触发一个动画事件，当鼠标移入的时候，字体变大 12345678910&lt;Style.Triggers&gt; &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseEnter&quot;&gt; &lt;!--异步的动画--&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Duration=&quot;0:0:1&quot; Storyboard.TargetProperty=&quot;FontSize&quot; From=&quot;10&quot; To=&quot;30&quot; /&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt;&lt;/Style.Triggers&gt; 效果如下： 3.4 MultiTrigger 与Trigger类似，但这种触发器联合了多个条件。只有满足了所有这些条件，才会启动触发器 示例代码： 1234567891011121314151617181920&lt;Window.Resources&gt; &lt;Style x:Key=&quot;Buttonstyle&quot; TargetType=&quot;Button&quot;&gt; &lt;Style.Triggers&gt; &lt;MultiTrigger&gt; &lt;MultiTrigger.Conditions&gt; &lt;Condition Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;/&gt; &lt;Condition Property=&quot;IsFocused&quot; Value=&quot;True&quot;/&gt; &lt;/MultiTrigger.Conditions&gt; &lt;MultiTrigger.Setters&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Red&quot; /&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;30&quot;/&gt; &lt;/MultiTrigger.Setters&gt; &lt;/MultiTrigger&gt; &lt;!--&lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;30&quot; /&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Red&quot;/&gt; &lt;/Trigger&gt;--&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt;&lt;/Window.Resources&gt; 当鼠标移入按钮，并获取焦点时，文字才会变红；效果如下： 3.5 MultiDataTrigger 联合多个数据触发器 链接…B站视频：https://www.bilibili.com/video/av70392459?p=4]]></content>
      <categories>
        <category>microsoft</category>
        <category>WPF</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WPF学习笔记(一)入门基础]]></title>
    <url>%2FWPF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[WPF学习笔记(一)入门基础一、WPF概述 为Windows创建具有视觉效果的用户体验的桌面客户端应用程序 WPF通过一系列全面的应用程序开发功能扩展了核心，这些功能包括可扩展应用程序标记语言（XAML），控件，数据绑定，布局，2D和3D图形，动画，样式，模板，文档，媒体，文本和版式 1. WPF项目生成的项目文件结构打开Visual Studio2019 创建“WPF应用程序”，默认生成的文件结构如下图： 在App.xaml中的“StartupUri”属性可以指定项目运行时的启动窗体。还可以定义我们需要的系统资源以及引入程序集等如下图： 2. 命名空间在许多 XAML 文件的根标记中的命名空间声明内，通常可看到两个 XML 命名空间声明。 第一个声明默认映射整个 WPF 客户端/框架 XAML 命名空间：默认是没有前缀的 1xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; 第二个声明映射单独的 XAML 命名空间，（通常）将其映射到 x: 前缀。 1xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; 2.1 x:Class 这个Attribute作用是告诉XAML编译器将XAML标签的编译结果与后台代码中指定的类合并，在使用x:Class时必须遵循以下要求： 这个Attribute只用于根节点 使用x:Class的根节点的类型要与x:Class的值所指示的类型保持一致 x:Class的值所指示的类型在声明时必须使用partial关键字 2.2 x:ClassModifier 这个Attribute作用是告诉XAML编译由标签生成的类具有怎么样的访问控制级别.使用x:ClassModifier时需要注意事项： 标签必须具有 x:Class Attribute x:ClassModifier的值必须与x:Class所指示类的访问控制级别一致 x:ClassModifier的值随后台代码的编译语言不同而有所不同，具体参看TypeAttributes枚举类型 2.3 x:Name XAML标签是对象，一个XAML变迁对应着一个对象，这个对象一般是一个控件的实例。 不带名称的XAML对象声明只负责声明对象而不负责为这些对象声明引用变量。 如果我们需要为对象准备一个引用变量以便在C#代码中直接访问就必须显示告诉XAML编译器，为这个对象声明引用变量就要用到x:Name x:Name的作用有两个： 告诉XAML编译器，当一个标签带有x:Name时除了为这个标签生成对应实例以外还要为这个实例声明一个引用变量，变量名就是x:Name的值 将XAML标签所对应对象的Name属性（如果有）也设置为x:Name的值，并把这个值注册到UI树上以方便查找 Tips：在XAML代码中应该使用Name还是x:Name Name属性定义在FrameworkElement类中，这个类是WPF控件类的基类，所有的WPF控件都有Name这个属性。当一个元素具有Name属性时，使用Name或者x:Name效果是一样的。对于那些没有Name属性值的元素，为了在XAML声明时也创建引用变量以便在C#代码中访问，我们只能使用x:Name。 2.4 x:FieldModifier. x:FieldModifier用来在XAML里改变引用变量访问级别 使用x:Name后XAML标签对应实例具有自己的引用变量，而且这些引用变量都是类的字段。默认情况下，这些字段的访问级别按照面向对象的封装原则被设置成internal。有时候我们需要从一个程序集访问另外一个程序集中窗体的元素，这个时候需要把访问控件的引用变量改为public级别。 注意：因为x:FieldMOdifier是用来改变引用变量访问级别的，所有使用x:FieldModifer的前提是这个标签同时使用x:Name，否则无法通过Name来引用变量。 二、WPF中的XAML XAML是基于XML的声明性标记语言，作为编程代码实例化和初始化对象 Xamarin.Forms 开发人员可以定义用户界面用作所有 Xamarin.Forms 视图、 布局和页面，以及自定义类。 可以编译或可执行文件中嵌入的 XAML 文件 1. XAML的优缺点（1）优点： 更简洁和可读性 XML中固有的父-子层次结构 可以轻松手动编写，也可以通过可视化设计工具生成 （2）缺点 XAML 不能包含代码。 必须在代码文件中定义所有事件处理程序。 XAML 不能包含重复处理的循环。 (但是，最值得注意的是 ListView 可以生成多个子级中的对象基于其 ItemsSource 集合。) XAML 不能包含有条件处理（但是，数据绑定可以引用，可有效地处理某些条件的代码基于绑定转换器。 XAML 通常无法实例化类未定义无参数构造函数。（但是，有时会解决此限制问题的方法。） XAML 通常不能调用方法。（同样，此限制可以有时克服。） 2. 为对象属性赋值的方式 利用Attribute=value的形式 1234//直接写在标签内&lt;Button Width=&quot;120&quot; Height=&quot;30&quot; Grid.Row=&quot;3&quot; &gt; &lt;Rectangle Width=&quot;20&quot; Height=&quot;20&quot; Stroke=&quot;DarkBlue&quot; Fill=&quot;LawnGreen&quot; /&gt;&lt;/Button&gt; 属性标签的形式 1234567891011&lt;Window.Resources&gt; &lt;style&gt; ... &lt;/style&gt;&lt;/Window.Resources&gt;//&lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition /&gt; &lt;/Grid.ColumnDefinitions&gt;&lt;/Grid&gt; 标签扩展 12&lt;TextBlock x:Name=&quot;tb&quot; Text=&quot;&#123;Binding ElementName=sld,Path=Value&#125;&quot; /&gt;&lt;Slider x:Name=&quot;sld&quot; Grid.Row=&quot;4&quot; Value=&quot;50&quot; Maximum=&quot;100&quot; Minimum=&quot;0&quot; /&gt; 三、学习中…链接… 刘铁猛老师教学视频：https://www.bilibili.com/video/av38367210?from=search&amp;seid=17560756528935135904]]></content>
      <categories>
        <category>microsoft</category>
        <category>WPF</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>WPF</tag>
        <tag>XAML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 料你也不想再过一次]]></title>
    <url>%2F2019-%E6%96%99%E4%BD%A0%E4%B9%9F%E4%B8%8D%E6%83%B3%E5%86%8D%E8%BF%87%E4%B8%80%E6%AC%A1.html</url>
    <content type="text"><![CDATA[2019 料你也不想再过一次 前言 在你为2020跨年而狂欢的时候，不知道还记不记得2019年初立的flag。第一批90后已经步入了三十岁的乐园😔，我们也该不远了。。。 我觉得在2020来临之际，应该静下心来想想，从毕业到进入社会这么些年来，你到底真正做了多少实事。有多少的时间是用来提升自己，努力成长的，又有多少的时间是用来挥霍、虚度的。 存款多少？或者欠款多少？一年到头，看着当初立里的flag，可能四分之一都没有完成的时候，或许自己应该是提不起来什么兴致跨年狂欢！ 2019回顾 对我而言，2019很平淡，没有暴富，依然没有存款，但不容置疑这是2017-2019这三年以来最好的一年了。从北京到天津，一路坎坷，没什么大悲大喜，但总归有了好转的苗头，虽然与心中预期的相差甚远，但正在路上，虽然缓慢，但一切都在往好的方向发展…… 工作17年毕业，选了一条曾经做梦也没想过的路，“程序员”—-这个折腾了我一年多的职业。 在这之前毫无编程基础，掉头转战IT。刚毕业的我，身无分文，带着一张信用卡就孤身一人去了北京，进了培训班（此处省略一万字…）。 那段时间是我最难熬时候，每个月房租、花呗、信用卡、学费，得支出好一大笔钱，然而零收入的我是怎么度过来的，这些不想再提，但期间资助过我的人，会牢记在心里，来日必当重谢！ 2019三月份离职，折腾了两个来月，也没什么起色，一度的以为自己就是天煞孤星啊，又恰逢互联网寒冬，内心的火好像就要被这寒风吹灭了…… 之后不甘的离开北京，来到了天津，她的城市，当时的我不知道是忧还是喜。幸好，有公司愿意接纳我，我呢也就这么迷迷糊糊的去了。奈何公司技术栈是微软全家桶😔，WPF、WinForm、Xamarin.Forms一大堆，两个字总结我当时的心情——卧槽！怎么办呢，学呗。怎么学呢？啃官网呗，我×××……，只能说网上找点新文章真的好难😭 好好的一前端(虽然很菜…)，莫名其妙搞.NET总感觉很别扭。尽管微软真的很厉害，尽管东西是好东西，但直到今天还是心心念念我的vue/react，想学的Flutter还是没来得及学。 搞得我精神恍惚，这种身在曹营心在汉的境地让我很是不舒服！ 工作虽不顺利，但至少有了起色，唯一能让我欣慰的大概就是还清了我北京的学费吧。希望2020年，一路向前！ 感情很难想象像我这种情况还有女生愿意陪着我，一直很感激。 这一年，只能说时运不济，在我最没资格谈情说爱的时间，却留了你一席之地，可能注定就会是悲剧。 没有预料中的跨年计划，没有任何的仪式感，当心中所预计的，看着一点点的变得不可能，我觉得强颜欢笑是件很难的事…… 给我的教训，当你连你自己都养不活的时候，别想那些没用的，努力让自己变得有钱才是正道！！ 2020展望 展望不展望的倒不是很重要，关键是2020年第一天，Flag暂时先不立了，因为打脸总会来的太快…. 感情方面，就希望我们能有一个好的结局吧，不管是好聚好散，还是修成成果，我们都能笑脸相迎，坦然面对… 工作上，就祝我不在重复2019年的状态，不忘初心，一路向前，早日事业有成！ 最后祝她越来越好！]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我有属于我的天]]></title>
    <url>%2F%E6%88%91%E6%9C%89%E5%B1%9E%E4%BA%8E%E6%88%91%E7%9A%84%E5%A4%A9.html</url>
    <content type="text"><![CDATA[百度百科 《蜗牛》是周杰伦在自己事业处于低潮时所创作的，当时周杰伦还未正式出道，整天就是帮其他人写歌，心情非常不好，于是决定写一首歌勉励一下自己，同时也为了鼓励年轻人能够像蜗牛一样为了自己的目标一步一步往前爬。之后许茹芸听了周杰伦为别人所创作的作品，感觉很特别，就联络公司跟周杰伦邀歌，于是周杰伦就把这首《蜗牛》给了许茹芸演唱。 《蜗牛》 作词：周杰伦 作曲：周杰伦 演唱：周杰伦 该不该搁下重重的壳 寻找到底哪里有蓝天 随着轻轻的风轻轻的飘 历经的伤都不感觉疼 我要一步一步往上爬 等待阳光静静看着它的脸 小小的天有大大的梦想 重重的壳挂着轻轻的仰望 我要一步一步往上爬 在最高点乘着叶片往前飞 小小的天流过的泪和汗 总有一天我有属于我的天 我要一步一步往上爬 在最高点乘着叶片往前飞 任风吹干流过的泪和汗 我要一步一步往上爬 等待阳光静静看着它的脸 小小的天有大大的梦想 我有属于我的天 任风吹干流过的泪和汗 总有一天我有属于我的天]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>Jay</tag>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配方案]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[移动端自适应布局配置 vw + rem 当我们写移动端页面时，会遇到自适应和兼容性等方面的问题，单纯的l指示利用rem或者vw/vh都不尽人意，有幸看见大神的设计思路，感觉很厉害，由此记录学习~ 1. 原理1.1 rem布局与vw/vh rem：相对于根元素html的字体大小的单位 rem布局原理：根据屏幕分辨率的不同，动态修改根字体的大小，让所有用rem为单位的元素跟着屏幕尺寸一起缩放，从而达到自适应的效果。 例如：宽度为750px的设计稿，尺寸可以这样设定 123html &#123; font-size: calc(100vw / 7.5);//除以的7.5是根据设计稿的屏幕宽度来定的，这样750px宽度下根元素字体大小则为750px/7.5=100px=1rem&#125; 1.2 设计思路 根据设计稿将html的gont-size设置为100px；比如750px的设计稿就除以7.5。此时100px=1rem，后续计算起来会方便很多。 以上设计思路的最大优点就是：方便计算。 2. 优化2.1 重置默认字体考虑到不改变浏览器默认字体大小的展示，因此要重置页面页面字体大小为浏览器默认的大小 1234567html &#123; font-size: calc(100vw / 7.5);&#125;#app &#123; font-size: initial; //重置页面字体大小恢复为浏览器默认16px，否则就显示成50px了&#125; 2.2 限制根元素字体大小的最大值、最小值上面的设计的页面虽然看起来适配得很好，但是你会发现它会无限制放大，在大屏上很不好看。可以通过给根元素字体大小限制最大最小值，以及 body 也增加最大最小宽度限制，这样就可以改善用户体验了。 1234567891011121314151617181920212223html &#123; //设置根字体大小单位为vw，页面元素的尺寸单位都设为rem，搭配vw和rem，可实现布局根据视口变化而变化 font-size: calc(100vw / 7.5); // 同时，通过Media Queries 限制根元素字体最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125;#app &#123; font-size: initial;&#125; 3. 总结 该设计方法简介方便，增加了最大最小宽度的限制，用户视觉体验更好。 原文链接： 基于Vue的移动端h5项目总结 利用视口单位实现适配布局]]></content>
      <categories>
        <category>大前端...</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>H5</tag>
        <tag>大前端</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缘来，你也走过这里]]></title>
    <url>%2F%E7%BC%98%E6%9D%A5%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%B5%B0%E8%BF%87%E8%BF%99%E9%87%8C.html</url>
    <content type="text"><![CDATA[为何 又是平安夜，应该对这种节日从来不感冒的，但大冷天的，看着人来人往的街道，总会露出姨母般的笑容……😼😼😼 缘来，你也走过这里​ ——作者:零点风声天地之大， 芸芸众生， 人来人往擦肩而过； 未曾奢想， 与之相逢， 萍水交集缘深缘浅； 偶感欣喜， 时有叹息， 若非前世因果循环， 岂能今生机缘巧遇； 情之无偿， 義之无余， 此后便是魂牵梦绕； 绝之无情， 断之无义， 此后便是肝肠寸断； 莽然回首， 心静如水，皆如往常； 若无相识，便无思愁， 岂会朝朝暮暮眷恋； 若无相望，便无欲求， 岂会日日夜夜期盼； 若无……缘来缘去 何须介怀。 平安夜…快乐一下 …… 回家睡觉🙁]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所求为何]]></title>
    <url>%2F%E6%89%80%E6%B1%82%E4%B8%BA%E4%BD%95.html</url>
    <content type="text"><![CDATA[我是小妖怪 “我是小妖怪，逍遥又自在，杀人不眨眼，吃人不放盐！”，头疼的厉害，难道我命不久矣…？&gt;_&lt; 尽管丢了我伦的版权，但还是习惯了云村这个温暖的地方，为了不顾此失彼，我下了咪咕音乐😔，占块儿地方而已，皆大欢喜😊 1. 网易云热评《借我》 “你好，方便借一生说话吗？” “余生洗耳恭听。” 2. 网易云热评《路过人间》 人生最好的三个词： “久别重逢，失而复得，虚惊一场。” 却唯独没有一个词叫“和好如初”， 和好容易，如初多难啊. 3. 网易云热评《熬》 “你怎么把生活过成现在这个样子的？” “正常发挥啊。” “那以后怎么办？” “熬。” 4. 网易云热评《我爱的人》 故事不长 也不难讲 只不过是 相识一场 爱而不得 5. 网易云热评《哑巴》 也许世间最好的默契， 不是有人懂你的言外之意， 而是有人心疼你的欲言又止。 6. 网易云热评《如风过境》 希望你别像风 在我这里掀起了万般波澜 却又跟云去了远方 7. 网易云热评《偷身》 “你羡慕我 一身潇洒，无牵无挂， 我却羡慕你，有家，有他，有人等你回家”。 8. 网易云热评《之外》 高中时一个同学沉迷网络，时常半夜翻墙出校上网。一日他照例翻墙，翻到一半就拔足狂奔而归，面色古怪，问之不语。从此认真读书，不再上网，学校盛传他见鬼了。后来他考上名校，后来我们问到这事，他沉默良久说，那天父亲来送生活费，舍不得住旅馆，在墙下坐了一夜。 9. 网易云热评《Sleepyhead》 有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了； 有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了 。 写在最后 本文内容摘录自网易云热评]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>热评</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS技巧(一)之隐藏滚动条]]></title>
    <url>%2FCSS%E6%8A%80%E5%B7%A7-%E4%B8%80-%E4%B9%8B%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1.html</url>
    <content type="text"><![CDATA[CSS实现隐藏滚动条的同时还可以滚动的三种方式1. 前言 平时会遇到很多有关CSS的特殊用法以及技巧，等哪天自己有用到了，就找不到是在哪儿见过，所以在此单独做一分类，专门将它们收藏在一起，方便自己日后翻阅调用… 1.1 关于该篇 该篇总结了纯CSS实现隐藏滚动条的同时又能保持滚动的几种方法，以下三种方法感觉很不错 2. 方法一：通过 ::-webkit-scrollbar 伪元素 简单粗暴，但是兼容性不好，不兼容IE 12345678910//chrome 和Safari.inner-container::-webkit-scrollbar &#123; display: none;//width:0 !impotant;&#125; //IE 10+.inner-container &#123; -ms-overflow-style: none; &#125; //Firefox.inner-container &#123; overflow: -moz-scrollbars-none; &#125; 3. 方法二：外层元素 overflow: hidden， 内层元素absolute定位 兼容性较好，绝对布局不用计算滚动条宽度 1234567891011121314151617181920212223242526// CSS 样式&lt;style&gt; .element, .outer-container &#123; width: 200px; height: 200px; &#125; .outer-container &#123; position: relative; overflow: hidden; &#125; .inner-container &#123; position: absolute; overflow-x: hidden; overflow-y: scroll; &#125;&lt;/style&gt;// html 结构&lt;div class="outer-container"&gt; &lt;div class="inner-container"&gt; &lt;div class="element"&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. ... &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 4. 方法三：父元素overflow: hidden, 子元素宽度 100% + 滚动条宽度 兼容性好，但是需要计算滚动条的宽度 12345678910111213141516171819// CSS 样式&lt;style&gt; .parent &#123; width: 200px; overflow: hidden; &#125; .child &#123; height: 200px; width: calc(100% + 17px); overflow: auto; &#125;&lt;/style&gt;// html 结构&lt;div class="parent"&gt; &lt;div class="child"&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. ...&lt;/div&gt; 5. 总结 以上三种方法其实都很好。方法一好像用过几次，虽然不兼容万恶的IE，但感觉真挺爽的。 该类型的文章篇幅基本都会很小，但是数量会很多，以后会不定期的更新，统一放在《CSS技巧》这一分类中。平时的工作、学习中随时遇到随时记，虽然是很小的知识点，但积少成多，终有一日会水滴石穿~]]></content>
      <categories>
        <category>CSS</category>
        <category>大前端...</category>
        <category>CSS技巧收录</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客常用命令]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一. 引言 本文记录了Hexo博客搭建过程中常用的一些命令，以及自己平时写博客过程中频繁使用的几个命令。因为我发现自己偶尔会犯混，所以在此简洁的记录一下，防止日后又一顿虎操作。。。😔 二. Hexo常用命令1. init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 2. new（重要）1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1$ hexo new "post title with whitespace" 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about/me "About me" 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot; 注意！title 是必须指定的！如果你这么做并不能达到你的目的： 1hexo new page --path about/me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 3. generate（重要）1$ hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 该命令可以简写为 1$ hexo g 4. publish1$ hexo publish [layout] &lt;filename&gt; 发表草稿。 5. server（重要）1$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 6. deploy（重要）1$ hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为： 1$ hexo d 自己的博客中引入了豆瓣插件，由于该指令会与hexo-douban冲突，所以该指令不能使用简写形式，只能使用全称… 7. render1$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 8. migrate1$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 9. clean（重要）1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 10. list1$ hexo list &lt;type&gt; 列出网站资料。 11. version1$ hexo version 显示 Hexo 版本。 三. 选项1. 安全模式1$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 2. 调试模式1$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 3. 简洁模式1$ hexo --silent 隐藏终端信息。 4. 自定义配置文件的路径12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml 自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如： 12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml 当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。 5. 显示草稿1$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 6. 自定义 CWD1$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 四. 更新中… 后续有用到的新指令，会及时更新过来，毕竟…我真的很健忘！！😭]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>2019</tag>
        <tag>blog</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软Blazor框架学习笔记(一)]]></title>
    <url>%2F%E5%BE%AE%E8%BD%AFBlazor%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80.html</url>
    <content type="text"><![CDATA[微软Blazor框架学习笔记(一)一、概述Blazor是一个用于使用 .NET生成交互式客户端 Web UI 的框架： 使用C#代替JavaScript来创建丰富的交互式UI； 共享使用.NET编写的服务器端和客户端应用逻辑； 将UI呈现为HTML和CSS，以支持众多浏览器，其中包括移动浏览器。 使用.NET进行客户端web开发可提供以下优势： 使用C#代替JavaScript来编写代码； 利用现有的.NET的性能、可靠性和安全性； 始终高效支持Windows、Linux、macOS上的Visual Studio； 以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来生成。 二、托管模型Blazor WebAssembly 是一个单页面应用框架，用于使用 .NET 生成交互式客户端 Web 应用。 Blazor WebAssembly 使用开放的 Web 标准（没有插件或代码转换），并且适用于所有新式 Web 浏览器（包括移动浏览器） Blazor 的主体托管模型在 WebAssembly 上的浏览器中运行客户端Blazor WebAssembly 托管模型具有以下几个优点： 没有 .NET 服务器端依赖项。 应用在下载到客户端之后完全正常运行。 完全利用客户端资源和功能。 工作从服务器卸载到客户端。 不需要 ASP.NET Core web 服务器来托管应用程序。 无服务器部署方案可能（例如，通过 CDN 提供应用）。 Blazor WebAssembly 托管的缺点： 应用程序限制为浏览器的功能。 需要支持的客户端硬件和软件（例如，WebAssembly 支持）。 下载大小较大，应用需要较长时间才能加载。 .NET 运行时和工具支持不太成熟。 例如， .NET Standard支持和调试中存在限制。 Blazor 服务器 使用 Blazor 服务器托管模型，可在服务器上从 ASP.NET Core 应用中执行应用。 UI 更新、事件处理和 JavaScript 调用是通过 SignalR 连接进行处理。 Blazor 服务器托管模型具有以下几个优点： 下载大小明显小于 Blazor WebAssembly 应用，且应用加载速度快得多。 应用充分利用服务器功能，包括使用任何与 .NET Core 兼容的 Api。 服务器上的 .NET Core 用于运行应用程序，因此现有的 .NET 工具（如调试）可按预期方式工作。 支持瘦客户端。 例如，Blazor 服务器应用程序适用于不支持 WebAssembly 的浏览器以及资源受限设备上的浏览器。 应用程序的 .NET/C#代码库（包括应用程序的组件代码）不会提供给客户端。 Blazor 服务器托管的缺点： 通常存在较高的延迟。 每个用户交互都涉及网络跃点。 无脱机支持。 如果客户端连接失败，应用将停止工作。 对于包含多个用户的应用而言，可伸缩性非常困难。 服务器必须管理多个客户端连接并处理客户端状态。 为应用提供服务需要 ASP.NET Core 服务器。 不可能的无服务器部署方案（例如，通过 CDN 为应用提供服务）。 三、Razor ComponentsBlazor 应用基于组件 定义灵活的 UI 呈现逻辑。 处理用户事件。 可以嵌套和重用。 可以作为 Razor 类库或 NuGet 包共享和分发。 组件类 在razor组件文件中，使用HTML和C#的组合实现了组件 Blazor中的组件成为Razor组件组件名称必须以大写字符开头 组件是普通的C#类，可以放在项目中任何位置 若要从页面和视图呈现组件：使用RenderComponentAsync HTML方法 若要在组件中通过分部视图使用逻辑，请将分部视图逻辑分解为一个组件。 生成组件 在网页中添加计数器通常使用JavaScript，但是用Blazor时，可以使用C# 浏览器对各组建的请求（由顶部的@page指令指定）导致该组件呈现其内容 在＠code块中定义组件状态（属性、字段）和方法用于处理事件或定义其他逻辑 使用组件 使用HTML语法可以将组件添加到其他组件中 使用特性或子内容来指定组件参数，这些参数允许你设置子组件的属性 组件参数 由具有［Parameter］的组件类上的公共属性定义 子内容 组件可以设置另一个组件的内容；分配组件提供用于指定组件标记之间的内容 路由到组件 由＠page指令指定该组件为路由终结点 如果没有＠page指令，组件将无法处理路由的请求，但该组件仍可以被其他组件使用 依赖关系注入 Blzor Server应用程序，在 Startup.ConfigureServices 中注册为单一实例 ＠inject指令用于将服务实例注入到所需组件中 组件使用注入的服务来检索对象中的数组 blazor WebAssembly应用，则注入了HttpClient 数据绑定 对组件和DOM元素都是通过＠bind属性来完成的 通过使用@bind:formatDateTime格式字符串，现在还不能使用其他格式的表达式，如货币或数字格式 事件处理 @on{event}格式：onclick、onsubmit、onchange Lambda表达式 链式绑定捕获对组件的引用 组件引用提供了一种方法来引用组件实例，以便可以向该实例发出命令。捕获组件引用： 向子组件添加@ref属性 定义与子组件类型相同的字段 在外部调用组件方法以更新状态 Blazor 使用 SynchronizationContext 来强制执行单个逻辑线程。此 SynchronizationContext 上将执行 Blazor 引发的组件生命周期方法和任何事件回调。 如果必须根据外部事件（如计时器或其他通知）更新组件，请使用 InvokeAsync 方法，该方法将调度到 Blazor 的 SynchronizationContext。 持续更新中…]]></content>
      <categories>
        <category>microsoft</category>
        <category>Asp.NET Core</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>Microsoft</tag>
        <tag>Blazor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS语法基础篇]]></title>
    <url>%2FSASS%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E4%B8%80.html</url>
    <content type="text"><![CDATA[SASS基础语法学习一. 引言 本文仅仅记录自己的学习历程，作为自己日后翻阅复习之用，并无什么高深的见解，只为温故而知新… 二. 官方网站网： SASS中文网1. 安装 Sass有以下几种安装方式： 使用独立的安装包（各平台，需要手动添加环境变量） 链接… 使用NPM安装（各平台） 使用Chocolatey包管理工具安装（Windows） 使用Brew安装（macOS） Windows下需先安装Ruby注意：安装过程中请注意勾选Add Ruby executables to your PATH添加到系统环境变量 测试安装有没有成功 123ruby -v//如安装成功会打印ruby 2.2.2p95 (2015-04-13 revision 50295) [i386-mingw32] 更换gem源 123456789101112//1.删除原gem源gem sources --remove https://rubygems.org///2.添加国内淘宝源gem sources -a https://ruby.taobao.org///3.打印是否替换成功gem sources -l//4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 安装Sass和Compass使用Ruby自带的RubyGems系统 123//安装如下(如mac安装遇到权限问题需加 sudo gem install sass)gem install sassgem install compass sass常用更新、查看版本、sass命令帮助等命令： 12345678//更新sassgem update sass//查看sass版本sass -v//查看sass帮助sass -h 编译sass 命令行编译 12345678//单文件转换命令sass input.scss output.css//单文件监听命令sass --watch input.scss:output.css//如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：sass --watch app/sass:public/stylesheets 软件方式编译推荐koala&amp; codekit 2. SASS与SCSS .SASS它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式。这种格式以 .scss 作为拓展名。 123h1 color: #f00 background:#fff; .SCSS仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。 123h1&#123; color:#f00; background:#fff; 三. 变量的使用1. 变量申明 $ 写法：$highlight-color：#fff； 全局变量变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量）；不在嵌套规则内定义的变量则可在任何地方使用（全局变量） 将局部变量转换为全局变量可以添加 !global 2. 变量的引用 凡是css属性的标准值可存在的地方，变量就可以使用 3. 变量名 sass的变量名可以与css中的属性名和选择器名称相同，包括中划线、下划线 中划线和下划线两种方式是相互兼容的；用中划线声明的变量可以使用下划线的方式引用，反之亦然 四. 嵌套规则1. 父选择器标识符 —- &amp; 为父级元素添加 :hover等伪类时使用 &amp;还有另一种用法，可以在父选择器之前添加选择器 例如：在ie浏览器下才显示的样式 1234567#content aside &#123; color: red; body.ie &amp; &#123; color: green &#125;&#125;//编译后#content aside &#123;color: red&#125;;body.ie #content aside &#123; color: green &#125; 2. 群组选择器的嵌套 群组选择器规则内嵌的规则 12345.container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125;//编译为.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125; 内嵌在群组选择器的嵌套规则 12345nav, aside &#123; a &#123;color: blue&#125;&#125;//编译为nav a, aside a &#123;color: blue&#125; 3. &gt;、+和~ 可以把他们放在外层选择器后边或者里层选择器的前边： 123456789101112131415article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125;//编译为article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 4. 属性嵌套 在sass中属性也是可以嵌套的 嵌套属性的规则： 把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。就像css选择器嵌套一样，sass会把你的子属性一一解开，把根属性和子属性部分通过中划线-连接起来，最后生成的效果与你手动一遍遍写的css样式一样： 五. 导入SASS文件 随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。sass通过对css原有@import规则的改进直接支持了这一特性。 1. 利用@import规则 所有在被导入文件中定义的变量和混合器均可以在导入文件中使用导入文件时，可不用指明文件的全名，可省略文件后缀 2. 使用SASS部分文件 局部文件 那些专门为import命令而写的sass文件，并不需要生成对应的独立css文件，这样的sass文件成为局部文件 对于局部文件，有一些约定： 文件名以下划线开头：这样sass就不会在编译时单独编译这个文件输出css，而只是把这个文件用作导入 导入局部文件时，还可以不写文件按的全名，即省略文件名开头的下划线 可以被多个不同的文件引用 3. 默认变量值 反复申明同一个变量，最后一处申明会覆盖之前的值 利用 !default 标签，其含义是：如果这个变量被申明赋值了，那就用它申明的值，否则就用这个默认值 4. 嵌套导入 sass允许@import命令写在css规则内 被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效；这些变量和混合器不会全局有效。 5. 原生的CSS导入 不能用sass的@import直接导入以个原始的css文件，sass会误认为你是想用css原生的@import 因为sass语法完全兼容css，所以可以把原始的css’文件改名为.scss后缀 6. 静默注释 以//开头，注释内容直到行末 这种注释不会出现在生成的长css文件中 7. 混合器 当你的样式变得越来越复杂时，需要大段重用样式的代码的时候，独立变量就没法应付了；而通过混合器可以简单解决这一问题 避免滥用混合器 混合器中的CSS规则可以在混合器中使用嵌套规则；也可以使用&amp;符 给混合器传参 默认参数值通过$name:default-value的生命形式；默认值可以是写法与JS的function很像： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 可通过语法$name：value的形式来指定每个参数的值，这样就不用考虑参数的顺序了 8. 使用选择器继承(@extend)来精简CSS 减少重复的特性 基于面向对象的css的理念，利用继承器可以继承为另一个选择器定义的所有样式 通过@extend语法实现** 何时使用继承 混合器主要是用于展示性样式的重用，而类名是用于语义化样式的重用，所以继承应该是建立在语义化的关系上。一般在一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式时，可选用@extend的方式来继承样式 继承的高级用法 任何css规则都可以继承其他规则，几乎任何css规则也都可以被继承 六. 待续…]]></content>
      <categories>
        <category>CSS</category>
        <category>大前端...</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>CSS</tag>
        <tag>2019</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也不知道在写什么]]></title>
    <url>%2F%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E5%9C%A8%E5%86%99%E4%BB%80%E4%B9%88.html</url>
    <content type="text"><![CDATA[Singleton与Static的区别1. singleton 单例模式 单例模式，单例模式是一种被广泛使用的设计模式。指的是在应用整个生命周期内只能存在一个实例。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。 单例模式的特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其它对象提供这一实例。 单例模式的好处 使用单例模式可以限制对象实例的个数，除了返回实例的操作之外不能被new出来。这在某些需要限制对象访问的场合下是有用的。使用static的话并不能限制对象实例的个数。 在很多的操作中，比如说是建立目录、数据库操作等都需要这样的单线程操作。 最显而易见的好处是节约开销，比如数据库单例的好处是，每次你只需要去获取那个数据库的示例就好，不用每次都去创建一个实例。 2. static 静态类 静态类就是一个类里面都是静态方法和静态field，构造器被private修饰，因此不能被实例化。Math类就是一个静态类。 静态类的特点 只包含静态成员。 无法进行实例化。也就是无法使用new运算符创建类类型的变量，因此可以通过类名.变量名直接引用，而不需要new出一个类来 静态方法通常用于创建实用程序函数。不能包含实例构造函数。静态方法的调用直接在类上进行，不能在类的实例上调用。 会进行密封，因此不能继承。 它们不能继承自任何类（除了Object） 静态类的好处 static类有更好的效率。 编译器可以进行检查。 3. 区别 静态方法只能直接访问本类中的静态成员（通过实例化对象）可以访问到的其它类中的所有成员（包括静态和非静态） static有更好的访问效率，如果你的singleton不维持任何状态，仅仅是提供全局的访问，这个时候就适合用static，这样速度的也快； 静态类中只能有静态成员，不可以有非静态字段； 单例模式的灵活性更高，方法可以被override，因为静态类都是静态方法，所以不能被override； 单例模式会提供给你一个全局唯一的对象，静态类只是提供给你很多静态方法，这些方法不用创建对象，通过类就可以直接调用； 单例模式最大的好处就是节省内存空间，提高效率，因为他永远都只有一个实例！而static还是有可能被new出多个实例的，而这多个实例在用完之后也许就没用了，还要等待垃圾回收机制来回收，所以效率自然不如单例； 如果是一个非常重的对象，单例模式可以懒加载，静态类就无法做到； 什么是进程？ 当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源。而一个进程又是由多个线程所组成的。 什么是线程 线程是程序中的一个执行流，每个线程都有自己的专有寄存器(栈指针、程序计数器等)，但代码区是共享的，即不同的线程可以执行同样的函数。 什么是多线程？ 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。 多线程的好处： 可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率。 多线程的不利方面： 线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； 多线程需要协调和管理，所以需要CPU时间跟踪线程； 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题； 线程太多会导致控制太复杂，最终可能造成很多Bug。 参考链接：https://www.cnblogs.com/scotth/p/10450891.html]]></content>
      <categories>
        <category>microsoft</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>singleton - static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面试题收藏（持续更新中...）]]></title>
    <url>%2FJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E8%97%8F.html</url>
    <content type="text"><![CDATA[前言 本文仅记录平时学习过程中遇到的知识点，只实现了相应方法的核心原理，部分边界细节并未处理。为了防止日后遗忘，特此记录，方便日后记忆，学习之用！ 1. 实现一个call函数123456789101112// 将要改变this指向的方法挂到目标this上执行并返回Function.prototype.mycall = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let arg = [...arguments].slice(1) let result = context.fn(...arg) delete context.fn return result&#125; 2. 实现一个apply函数123456789101112131415Function.prototype.myapply = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 3. 实现一个bind函数123456789101112131415Function.prototype.mybind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; let _this = this let arg = [...arguments].slice(1) return function F() &#123; // 处理函数使用new的情况 if (this instanceof F) &#123; return new _this(...arg, ...arguments) &#125; else &#123; return _this.apply(context, arg.concat(...arguments)) &#125; &#125;&#125; 4. instanceof的原理1234567891011121314// 右边变量的原型存在于左边变量的原型链上function instanceOf(left, right) &#123; let leftValue = left.__proto__ let rightValue = right.prototype while (true) &#123; if (leftValue === null) &#123; return false &#125; if (leftValue === right) &#123; return true &#125; leftValue = rightValue.__proto__ &#125;&#125; 5. Object.create的基本实现原理1234function create(obj) &#123; function F() &#123;&#125; F.prototype = obj return new F() 6. new本质123456789101112131415161718function myNew (fun) &#123; return function () &#123; // 创建一个新对象且将其隐式原型指向构造函数原型 let obj = &#123; __proto__ : fun.prototype &#125; // 执行构造函数 fun.call(obj, ...arguments) // 返回该对象 return obj &#125;&#125;function person(name, age) &#123; this.name = name this.age = age&#125;let obj = myNew(person)('chen', 18) // &#123;name: "chen", age: 18&#125; 7. 实现一个基本的Promise123456789101112131415161718192021222324252627282930313233343536373839// ①自动执行函数，②三个状态，③thenclass Promise &#123; constructor (fn) &#123; // 三个状态 this.state = 'pending' this.value = undefined this.reason = undefined let resolve = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'fulfilled' this.value = value &#125; &#125; let reject = value =&gt; &#123; if (this.state === 'pending') &#123; this.state = 'rejected' this.reason = value &#125; &#125; // 自动执行函数 try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125; // then then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case 'fulfilled': onFulfilled() break case 'rejected': onRejected() break default: &#125; &#125;&#125; 8. 实现浅拷贝123456// 1. ...实现let copy1 = &#123;...&#123;x:1&#125;&#125;// 2. Object.assign实现let copy2 = Object.assign(&#123;&#125;, &#123;x:1&#125;) 9. 实现一个基本的深拷贝1234567891011121314// 1. JOSN.stringify()/JSON.parse()let obj = &#123;a: 1, b: &#123;x: 3&#125;&#125;JSON.parse(JSON.stringify(obj))// 2. 递归拷贝function deepClone(obj) &#123; let copy = obj instanceof Array ? [] : &#123;&#125; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i] &#125; &#125; return copy&#125; 10. 使用setTimeout模拟setInterval12345// 可避免setInterval因执行时间导致的间隔执行时间不一致setTimeout (function () &#123; // do something setTimeout (arguments.callee, 500)&#125;, 500) 11. js实现一个继承方法// 借用构造函数继承实例属性123456789function Child () &#123; Parent.call(this)&#125;// 寄生继承原型属性(function () &#123; let Super = function () &#123;&#125; Super.prototype = Parent.prototype Child.prototype = new Super()&#125;)() 12. 实现一个基本的Event Bus123456789101112131415161718192021222324252627// 组件通信，一个触发与监听的过程class EventEmitter &#123; constructor () &#123; // 存储事件 this.events = this.events || new Map() &#125; // 监听事件 addListener (type, fn) &#123; if (!this.events.get(type)) &#123; this.events.set(type, fn) &#125; &#125; // 触发事件 emit (type) &#123; let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) &#125;&#125;// 测试let emitter = new EventEmitter()// 监听事件emitter.addListener('ages', age =&gt; &#123; console.log(age)&#125;)// 触发事件emitter.emit('ages', 18) // 18 13. 实现一个双向数据绑定12345678910111213141516171819let obj = &#123;&#125;let input = document.getElementById('input')let span = document.getElementById('span')Object.defineProperty(obj, 'text', &#123; configurable: true, enumerable: true, get() &#123; console.log('获取数据了') return obj.text &#125;, set(newVal) &#123; console.log('数据更新了') input.value = newVal span.innerHTML = newVal &#125;&#125;)input.addEventListener('keyup', function(e) &#123; obj.text = e.target.value&#125;) 14. 实现一个简单路由12345678910111213141516171819202122class Route&#123; constructor()&#123; // 路由存储对象 this.routes = &#123;&#125; // 当前hash this.currentHash = '' // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener('load', this.freshRoute, false) window.addEventListener('hashchange', this.freshRoute, false) &#125; // 存储 storeRoute (path, cb) &#123; this.routes[path] = cb || function () &#123;&#125; &#125; // 更新 freshRoute () &#123; this.currentHash = location.hash.slice(1) || '/' this.routes[this.currentHash]() &#125;&#125; 15. 实现懒加载123456789101112&lt;ul&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/1.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/2.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/3.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/4.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/5.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/6.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/7.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/8.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/9.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./imgs/default.png" data="./imgs/10.png" alt=""&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516let imgs = document.querySelectorAll('img')// 可视区高度let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeightfunction lazyLoad () &#123; // 滚动卷去的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop for (let i = 0; i &lt; imgs.length; i ++) &#123; // 得到图片顶部距离可视区顶部的距离 let x = clientHeight + scrollTop - imgs[i].offsetTop // 图片在可视区内 if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123; imgs[i].src = imgs[i].getAttribute('data') &#125; &#125;&#125;setInterval(lazyLoad, 1000) 16. rem实现原理1234567function setRem () &#123; let doc = document.documentElement let width = doc.getBoundingClientRect().width // 假设设计稿为宽750，则rem为10px let rem = width / 75 doc.style.fontSize = rem + 'px'&#125; 17. 手写实现AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 1. 简单实现// 实例化let xhr = new XMLHttpRequest()// 初始化xhr.open(method, url, async)// 发送请求xhr.send(data)// 设置状态变化回调处理请求结果xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 2. 基于promise实现function ajax (options) &#123; // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || 'get' // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; // 返回一个Promise实例 return new Promise ((resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject('请求超时') // 监听状态变化回调 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; // 错误回调 xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key])) &#125; encodeData = paramArr.join('&amp;') &#125; // get请求拼接参数 if (method === 'get') &#123; // 检测url中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&amp;' // 拼接url url += encodeData &#125; // 初始化 xhr.open(method, url, async) // 发送请求 if (method === 'get') xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) &#125; &#125;)&#125; 18. 实现拖拽1234567891011121314151617181920212223242526272829303132window.onload = function () &#123; // drag处于绝对定位状态 let drag = document.getElementById('box') drag.onmousedown = function(e) &#123; var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) &#123; // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left &lt; 0) &#123; left = 0 &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123; left = window.innerWidth - drag.offsetWidth &#125; if (top &lt; 0) &#123; top = 0 &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123; top = window.innerHeight - drag.offsetHeight &#125; drag.style.left = left + 'px' drag.style.top = top + 'px' &#125; drag.onmouseup = function (e) &#123; this.onmousemove = null this.onmouseup = null &#125; &#125;&#125; 19. 实现一个节流函数123456789101112131415161718function throttle (fn, delay) &#123; // 利用闭包保存时间 let prev = Date.now() return function () &#123; let context = this let arg = arguments let now = Date.now() if (now - prev &gt;= delay) &#123; fn.apply(context, arg) prev = Date.now() &#125; &#125;&#125;function fn () &#123; console.log('节流')&#125;addEventListener('scroll', throttle(fn, 1000)) 20. 实现一个防抖函数12345678910111213141516function debounce (fn, delay) &#123; // 利用闭包保存定时器 let timer = null return function () &#123; let context = this let arg = arguments // 在规定时间内再次触发会先清除定时器后再重设定时器 clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(context, arg) &#125;, delay) &#125;&#125;function fn () &#123; console.log('防抖')&#125;addEventListener('scroll', debounce(fn, 1000)) 最后 后续也会持续更新，希望能对所有像我一样的前端新手都有所帮助。共同进步~]]></content>
      <categories>
        <category>大前端...</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>-JavaScript -面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coding Pages申请SSL/TLS证书错误]]></title>
    <url>%2FCoding-Pages%E7%94%B3%E8%AF%B7SSL-TLS%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF.html</url>
    <content type="text"><![CDATA[问题今天由于某种原因，我将我的个人站点部署到了Coding Pages上面，需要申请SSL/TLS证书，但是当我登陆进入Coding Pages服务的后台并点击申请证书时，竟然报错了！！！ 我重新点了申请，几秒后依然报错，并提示我半小时只能申请一次。我查看了下报错的提示信息，如下： urn:acme:error:unauthorized:Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx 好吧，本着有事就问度娘的一贯风格，百度了一下，发现了Coding Pages的官方文件：Coding Pages 常见问题 这时候按照官方文件的指引，找到了和我差不多一样的错误信息的解决方案： 错误原因：无法获取正确的域名验证信息解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 因为Coding Pages的静态Pages是免费的，而动态Pages是收费的，对于用Hexo搭建的静态站点，自然是选择免费的静态Pages服务就足够了。 于是解决方式1对我来说就不存在了，接着联想到之前我对部署在GitHub Pages上的个人站点进行了自定义域名绑定+域名解析设置，有些豁然开朗的感觉。 分析由于考虑到站点访问速度，以及后期SEO的各种问题，因此我的个人站点是同时部署到GitHub Pages和Coding Pages上的，接着在腾讯云域名解析里进行了配置：默认的解析线路将我的域名指向pages.coding.me，国外的解析路线则是指向了xxx.github.io。 之所以这样配置，是因为国内部分地区无法直接访问GitHub，自然就无法访问我部署在GitHub上的个人站点，于是我又选择了Coding.net的Pages服务，这样国内用户就可以快速访问到我部署在Coding Pages的个人站点，而国外用户则是快速访问到GitHub Pages上的个人站点。 问题就出现在这里，因为我第一次申请SSL/TLS证书的时候，还没有解析境外的线路，所以很快就申请成功了。后来添加了国外线路的解析，这导致在Coding Pages的后台申请证书时无法通过验证，自然就申请失败了。 分析到这里，我也基本知道怎么解决这个错误了。 解决方法由于我是在腾讯云购买的域名，于是登陆到腾讯云域名解析的后台系统，打开个人域名的解析设置，暂停对于境外线路的解析。这里暂停就行了，一般来说大概需要5分钟左右的生效时间，毕竟DNS解析是存在缓存的。 五分钟后，我又进入Coding Pages服务的后台，再一次申请SSL/TLS证书，果不其然，几秒钟后我申请证书成功了。 最后，再次返回腾讯云域名解析的后台，将境外解析的线路再次启用，嗯，完美！！！ 其他的申请错误个人暂时就遇到这一个问题，有其他问题的伙伴可自行查阅官方文件Coding Pages 常见问题。 明日灵笼上线，喜欢的小伙伴一起啊~~ 参考链接 Coding Pages的官方文件：Coding Pages 常见问题 https://www.cnblogs.com/yulinlewis/p/9595362.html]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法]]></title>
    <url>%2FMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[Markdown基础语法 一、概述 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的特点就是，让写作变得更简单，我们不用再考虑如何排版，我们只要专心于写作就好了，其目标就是实现「易读易写」。 二、基础语法2.1 标题 Markdown支持6种级别的标题，一个#是一级标题，二个#是二级标题，以此类推，对应html标签 h1 ~ h6。 除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制。使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。 示例： 1234567891011# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是三级标题 ###### 这是四级标题 以上标记显示效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是三级标题这是四级标题 2.2 文本1. 加粗​ 要加粗的文字左右分别用两个*号（或_号）包起来 2. 斜体​ 要倾斜的文字左右分别用一个*号或（或_号）包起来 3. 斜体加粗​ 文字左右分别用三个*号或（或_号）包起来 4. 下划线​ 使用&lt;u&gt;&lt;/u&gt;，中间写入内容 5. 删除线​ 要加删除线的文字左右分别用两个~~号包起来 ​ 以上標記示例： 123456789**这是加粗的文字***这是倾斜的而文字****这是斜体加粗的文字*** &lt;u&gt;这是有下划线的文字&lt;/u&gt;~~这是加出现的文字~~ ​ 以上标记显示效果如下： ​ 这是加粗的文字 ​ 这是倾斜的而文字 ​ 这是斜体加粗的文字 ​ 这是有下划线的文字 ​ 这是加出现的文字 PS：空行输入&amp;nbsp；换行的话要隔一行 2.3 列表1. 有序列表​ 语法：数字+点 Markdown将只关注你的第一个项目的数字编号，之后按enter会自动排序 ​ 示例： 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 ​ 效果如下： 列表內容 列表內容 列表內容 2. 无序列表​ 语法：用 _ + * 任意一种都可以 ​ 示例： 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 ​ 效果如下： 列表内容 列表内容 列表内容 ​ 列表是可以嵌套的！ 3. 任务列表​ 示例： 123- [ ] 围天安门跑三百圈- [x] 教学计划- [ ] 读一本书 ​ 效果展示： 围天安门跑三百圈 教学计划 读一本书 2.4 引用​ 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个… ​ 示例： 123&gt; Typora热爱文字更佳，码农或者文字工作者必备神器&gt;&gt; 所見所得的Markdown編輯器&gt;&gt;&gt; 書寫即為美學！ ​ 效果如下： Typora热爱文字更佳，码农或者文字工作者必备神器 所見所得的Markdown編輯器 書寫即為美學！ 2.5 图片​ 语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ​ 示例： 1![图片](https://picgo-img-1259503129.cos.ap-beijing.myqcloud.com/c31f7fdc1bb4d377e6e11073240bdcfc.jpg) ​ 效果如下： 2.6 超链接​ 语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 ​ 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) ​ 效果： ​ 简书​ 百度 注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。 2.7 分割线​ 三个或者三个以上的 - 或者 * 都可以。 示例： 1234*******------- 效果如下： 2.8 表格表格是Markdown语法中比较复杂的一个，其语法如下： 1234表头|条目一|条目二|:---:|:---:|:---:||项目|项目一|项目二| 示例： 123456姓名|技能|排行|:--:|:--:|:--:|:|刘备|哭|大哥||关羽|打|二哥||张飞|骂|三弟| 其效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 罵 三弟 ​ 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中，文字默认居中。 2.9 代码块 单行代码 语法：代码之间分别用一个反引号包起来 1`代码内容` 示例： 1`console.log(123456);` 效果： console.log(123456); 代码块 语法：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...​(```) 示例： 12345678(```)javascriptvar txt = &quot;&quot;;var numbers = [45, 4, 9, 16, 25]; numbers.forEach(myFunction);function myFunction(value) &#123; txt = txt + value + &quot;&lt;br&gt;; &#125;(```) 注意：这里的（）是为了防止转义，实际操作中没有括号 效果： 1234567 var txt = "";var numbers = [45, 4, 9, 16, 25]; numbers.forEach(myFunction);function myFunction(value) &#123; txt = txt + value + "&lt;br&gt;"; &#125; 注意：代码高亮需要在开头的三个反引号后面写上选用哪种语言 2.10 反斜杠 反斜杠相当于转义的作用，是一些符号以普通的符号显示出来 Markdown使用反斜杠\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理： 12345678910111213\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。 三、总结 Markdown的一些高级用法，像数学公式、制图等，小伙伴儿们可以参考官网的案例，我这里呢..就没必要去记了😂😂😂Markdown对喜欢写作的小伙伴儿们来说是一门必备的技能。如果你希望快速掌握Markdown，很简单，动起来吧！]]></content>
      <categories>
        <category>Blog</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博文]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87.html</url>
    <content type="text"><![CDATA[新手写博客应该写些什么~最近刚搭建了这么个博客，奈何自己也是前端小白一枚，苦于不知道该写什么比较好。于是乎，各种问度娘，借鉴各种大神的作品，最终总结出如下适合自己目前状况的一种套路： 内容为王，拒绝copy 一路坚持，总有收获 博客内容入门系列 备忘录 主要记录平时自己常用到的，容易忽视的一些知识，作为自己知识的巩固，也可以写自己收藏的比较好的网站，文章的分享等等，当然也可以写自己最近的计划之类的。 学习笔记 这一块可以写的东西好多，只要是自己平时get到的技能点，都可以写上去。 读书笔记 基础理解 学习心得 踩坑记录 自己工作中，学习中遇到的各种坑，你可以记录下来，总不能下次遇见在此掉进里面吧…，如果恰巧能帮助到别人一下下，那可是功德一件啊~ 生活随笔 个人日记什么的，自己个人呢有点想写，但怎么感觉有点怪怪的… 还是觉得，自己的小本本写着比较安心… 想写在自己博客的话，文章也是可以加密的！ 实战类 环境搭建 操作记录 主要写一些实战中，某些环境的搭建过程，操作步骤等 不要担心写的不好什么的，一定要自己动手写！坚持这么一年半载之后呢，就可以写一些比较深的东西了，比如： 模式的提炼 造轮子，各种可复用的组件等 各种工具的使用，源码分析 开源项目 和大家一样，我也是刚刚开始，记录以上内容，希望能一起进步。 路漫漫其修远兮，吾将上下而求索！ 坚持就是胜利，一起加油呀！ 共勉~ 参考链接 B站优质up主：CodeSheep]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
